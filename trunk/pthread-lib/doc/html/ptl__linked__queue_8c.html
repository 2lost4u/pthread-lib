<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>pthread-lib: ptl_linked_queue.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ptl_linked_queue.c File Reference</h1><code>#include &lt;pthread.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &lt;time.h&gt;</code><br>
<code>#include &lt;sys/time.h&gt;</code><br>
<code>#include &quot;<a class="el" href="ptl__queue_8h-source.html">ptl_queue.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="ptl__linked__queue_8h-source.html">ptl_linked_queue.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="ptl__util_8h-source.html">ptl_util.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#a62141495e57a2ab98b335379781d26e">ptl_lq_init_queue</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the queue, creating all memory needed to support this data structure.  <a href="#a62141495e57a2ab98b335379781d26e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#5d73deab1f436b611ee6bf6ca5df1fad">ptl_lq_destroy_queue</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This linked queue implementation is a simple FIFO queue with locking/blocking operations for all get and put operations.  <a href="#5d73deab1f436b611ee6bf6ca5df1fad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#96a22931a967690ed655174d8ac908f4">ptl_lq_add</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q, void *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available.  <a href="#96a22931a967690ed655174d8ac908f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#c67126ed8e6fc6c7aba60f8a232958db">ptl_lq_add_wait</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q, void *value, long timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available.  <a href="#c67126ed8e6fc6c7aba60f8a232958db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#6eb3e3d6461076426622742706bcd7a0">ptl_lq_clear</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all of the elements from this queue.  <a href="#6eb3e3d6461076426622742706bcd7a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#18b5cb9b029bda48d1693f931d545d8b">ptl_lq_peek</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves, but does not remove, the head of this queue.  <a href="#18b5cb9b029bda48d1693f931d545d8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#f0e438bed782a79fc9a85d95fd36c451">ptl_lq_get</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves and removes the head of this queue.  <a href="#f0e438bed782a79fc9a85d95fd36c451"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#77c2af7ac715ced5d88092c212c5e058">ptl_lq_get_wait</a> (<a class="el" href="structptl__q.html">ptl_q_t</a> q, void *value, long timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.  <a href="#77c2af7ac715ced5d88092c212c5e058"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptl__linked__queue_8c.html#db1af097d280e85e6a3c69ca65ff5669">ptl_lq_mutex</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="96a22931a967690ed655174d8ac908f4"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_add" ref="96a22931a967690ed655174d8ac908f4" args="(ptl_q_t q, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptl_lq_add           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. 
<p>
Inserts the specified element into this queue. 
</div>
</div><p>
<a class="anchor" name="c67126ed8e6fc6c7aba60f8a232958db"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_add_wait" ref="c67126ed8e6fc6c7aba60f8a232958db" args="(ptl_q_t q, void *value, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptl_lq_add_wait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
iserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available. 
<p>
placeholder 
</div>
</div><p>
<a class="anchor" name="6eb3e3d6461076426622742706bcd7a0"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_clear" ref="6eb3e3d6461076426622742706bcd7a0" args="(ptl_q_t q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptl_lq_clear           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all of the elements from this queue. 
<p>
placeholder 
</div>
</div><p>
<a class="anchor" name="5d73deab1f436b611ee6bf6ca5df1fad"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_destroy_queue" ref="5d73deab1f436b611ee6bf6ca5df1fad" args="(ptl_q_t q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptl_lq_destroy_queue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This linked queue implementation is a simple FIFO queue with locking/blocking operations for all get and put operations. 
<p>
A single lock is used to control both get and put. Like all linked list implementations, capacity is not a concern. Destroys the queue and frees the memory. This should be used when the queue is no longer going to be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>the queue to destroy </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f0e438bed782a79fc9a85d95fd36c451"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_get" ref="f0e438bed782a79fc9a85d95fd36c451" args="(ptl_q_t q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ptl_lq_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves and removes the head of this queue. 
<p>
placeholder<p>
It will block until an element is available. This function will block once it enters the function mutex. 
</div>
</div><p>
<a class="anchor" name="77c2af7ac715ced5d88092c212c5e058"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_get_wait" ref="77c2af7ac715ced5d88092c212c5e058" args="(ptl_q_t q, void *value, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptl_lq_get_wait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available. 
<p>
placeholder<p>
This function will block once it enters the function mutex. Returns 1 if item was attemtped to be retrieved, 0 if not. If item was retrieved, it will be populated in 'value'. If not, then 'value' will be assigned NULL.<p>
It may be a bad idea to try to get the lock constantly... timeout - time in seconds 
</div>
</div><p>
<a class="anchor" name="a62141495e57a2ab98b335379781d26e"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_init_queue" ref="a62141495e57a2ab98b335379781d26e" args="(ptl_q_t q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptl_lq_init_queue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the queue, creating all memory needed to support this data structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>queue to be initized. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="18b5cb9b029bda48d1693f931d545d8b"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_peek" ref="18b5cb9b029bda48d1693f931d545d8b" args="(ptl_q_t q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ptl_lq_peek           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptl__q.html">ptl_q_t</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves, but does not remove, the head of this queue. 
<p>
placeholder<p>
This function is read-only and therefore does not block. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="db1af097d280e85e6a3c69ca65ff5669"></a><!-- doxytag: member="ptl_linked_queue.c::ptl_lq_mutex" ref="db1af097d280e85e6a3c69ca65ff5669" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="ptl__linked__queue_8c.html#db1af097d280e85e6a3c69ca65ff5669">ptl_lq_mutex</a> = PTHREAD_MUTEX_INITIALIZER          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 6 23:07:29 2008 for pthread-lib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
